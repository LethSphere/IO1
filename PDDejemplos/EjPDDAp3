# -*- coding: utf-8 -*-
"""
@author: Violeth V, Julian S, Esteban L
"""

#MAIN
def main():
    n = 4

    sn_4 = [0, 100, 200, 300, 400]
    v_4 = [1, 1, 1, 1, 1]
    x_4 = [0, 0, 0, 0, 0]
    step_4 = (sn_4, v_4, x_4)

    sol = step(n, step_4, [])

    get_sol(sol)

if __name__ == "__main__":
    main()
#ITERACION DE LA FUNCION CALCULADORA
def step(n, last_step, cache):
    fn = []
    sn_op, fn_last, xn_op = last_step
    sn = step_prices(n)
    for s in sn: # Calcula los valores de la tabla
        fn_sn = []
        for i in range(1, 4):
            if s - cost(n, i) >= sn_op[0]: # Si alcanza el dinero para comprar i componentes tipo n
                j = 0
                for j, s_last in enumerate(sn_op):  # n -- n + 1
                    if s - cost(n, i) == s_last:
                        break
                fn_sn.append(round(prob(n, i) * fn_last[j], 3))
            else:
                break
        #print(fn_sn)
        fn.append((s, fn_sn))
    xop_current = []
    values = []
    for (s, fs) in fn: #Elije los valores optimos para cada valor de s
        x_op = 0
        value = -10000
        for i, v in enumerate(fs):
            if v > value:
                x_op = i + 1
                value = v
        xop_current.append(x_op)
        values.append(value)

    current_step = (sn, values, xop_current)
    cache.append(current_step)

    if n != 1:
        return step(n - 1, current_step, cache)
    else:
        return cache
#CALCULO DE LA SOLUCION
def get_sol(sol):
    budget = 1000
    count = []
    spent = []
    last_step = sol[-1]
    __, prob, __ = last_step
    for j, step in enumerate(reversed(sol)):
        sn, values, xvals = step

        for i in range(len(sn)):
            if sn[i] == budget:
                count.append(xvals[i])
                coste = cost(j + 1, xvals[i])
                spent.append(coste)
                budget -= coste
    nombres = ["Pila", "Microcontrolador", "Memoria", "Transistor"]
    print("La soluci√≥n es:")
    for i in range(len(count)):
        print("Del componente {} se colocan {} unidades en paralelo, gastando ${}".format(nombres[i], count[i], spent[i]))
    print("\n")

    for i in range(len(count)):
        print("x{}: {}. ".format(i + 1, count[i]))
    print("\nLa probabilidad de que el sistema funcione es de: {}%".format(prob[0] * 100))
    #FUNCION COSTO PARA LOS COMPONENTES
def cost(n, xn):
    n -= 1
    xn -= 1
    #MATRIZ
    price = [[100, 200, 300],[200, 400, 500],[100, 300, 400],[200, 300, 400]]
    return price[n][xn]
#CALCULO DE LOS COMPONENTES SEGHUN LAS MATRICES YA UTILIZADAS Y PREDEFINIDAS
def step_prices(n):
    n -= 1
    #MATRIZ
    step_prices = [[1000],[500, 600, 700, 800, 900],[300, 400, 500, 600, 700],[200, 300, 400, 500, 600],[0]]
    return step_prices[n]
#FUNCION QUE RETORNA EL MINIMO VALOR POSIBLE PARA SUS COMPONENTES
def min_price(n):
    n -= 1
    min_price = [600, 500, 300, 200, 0]
    return min_price[n]
#FUNCION DE PROBABILIDAD PARA LOS COMPONENTES
def prob(n, xn):
    n -= 1
    xn -= 1
    #MATRIZ
    probs = [[0.5, 0.6, 0.8],[0.6, 0.7, 0.8],[0.7, 0.8, 0.9],[0.5, 0.7, 0.9]]
    return probs[n][xn]
